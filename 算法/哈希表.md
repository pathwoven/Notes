# 哈希表
又名散列表。  
一般用于快速判断一个**元素是否出现**在集合里。  
使用**哈希函数**把关键码映射到哈希表上，hashFunction=hashCode(name)%tableSize
## 基础
### 哈希碰撞
解决方法：  
- 拉链法
- 线性探测法
#### 拉链法
发生碰撞的元素被存储在链表中  
<p align=center><img src="imgs/哈希表.png" width=60% /></p>

#### 线性探测法
一定要保证tableSize > dataSize，依靠哈希表中的空位解决碰撞问题。  
### 常见的哈希结构
数组、set(unordered_set)、map(unordered_map)
#### set与map
set底层实现及优劣势如下：  
<p align=center><img src="imgs/哈希表-1.png" width=60% /></p>
map底层实现及优劣势如下：  
<p align=center><img src="imgs/哈希表-2.png" width=60% /></p>

set,multiset,map,multimap 底层为**红黑树**，而无序的unordered_set与unordered_map底层为哈希表，红黑树的key值是有序的，而哈希表是无序的（其排布是按哈希值映射，而非key值）。

## 两个数组的交集
求取两个相同的元素
### 方法
- unordered_set
- 数组
#### 数组
unordered_set非常方便于去重，但是对比起数组，它还需要做hash运算，且可能有更高的内存开销。故而，当题目有**规定数值范围**时，可以直接使用数组。
## 两数之和
给定一个数组与目标值，找出其中相加等于目标值的两个数。
### 方法
- 暴力破解
- 哈希map，根据加数与和求另一个加数
#### map
本题暴力破解很简单，像这样找两个数的，需要额外注意两个数的关联，是否<u>找到一个数即可唯一**确定另一个数**</u>  
在本题中，给出一个数，根据目标值即可确定另一个数，也就是说实际上不需要真的把数组两两相加，只需要确定数组中有无另一个加数，这时就可以使用map来记录已出现过的数。以此，可以达到O(n)的复杂度。